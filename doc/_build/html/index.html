<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to ZAP’s documentation! &mdash; zap 0.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="zap 0.3 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">zap 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-zap-s-documentation">
<h1>Welcome to ZAP&#8217;s documentation!<a class="headerlink" href="#welcome-to-zap-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p>ZAP (the Zurich Atmosphere Purge) is a high precision sky subtraction tool which can be used as complete sky subtraction solution, or as an enhancement to previously sky-subtracted data.  The method uses PCA to isolate the residual sky subtraction features and remove them from the observed datacube. Though the operation of ZAP is not dependent on perfect flatfielding of the data in a MUSE exposure, better results are obtained when these corrections are made ahead of time.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>ZAP requires the following packages:</p>
<ul class="simple">
<li>Numpy 1.6.0 or later</li>
<li>Astropy v1.0 or later</li>
<li>SciPy v0.13.3 or later</li>
</ul>
<p>Many linear algebra operations are performed in ZAP, so it can be beneficial to use an alternative BLAS package. In the Anaconda distribution, the default BLAS comes with numpy linked to OpenBlas, which can amount to a 20% speedup of ZAP.</p>
</div>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>In its most hands-off form, ZAP can take an input fits datacube, operate on it, and output a final fits datacube.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">mpdaf_user</span> <span class="kn">import</span> <span class="n">zap</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Care should be taken, however, since this case assumes a sparse field.</p>
<p>There are a number of options that can be passed to the code which we tabulate here, and describe in several different use cases.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="18%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Default</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>outcubefits</td>
<td>&#8216;DATACUBE_ZAP.fits&#8217;</td>
<td>the fits filename for the output datacube.</td>
</tr>
<tr class="row-odd"><td>clean</td>
<td>True</td>
<td>Interpolates over NaN values in the datacube to allow processing on all
spectra. The NaN values are replaced in the final datacube.
Any spaxel that includes a NaN pixel will hinder the calculation, so this
step is used to maximize the number of contributors. The NaN values are
reinserted into the final datacube.</td>
</tr>
<tr class="row-even"><td>zlevel</td>
<td>&#8216;median&#8217;</td>
<td>This option is used to define the method for determining the zeroth order
subtraction of the sky. This is used to remove any systematic sky feature
that exists over the whole field. Options are &#8216;median&#8217;, &#8216;sigclip&#8217;, and &#8216;none&#8217;.
The &#8216;none&#8217; option should only be applied when ZAP is applied to enhance a
previous sky subtraction.</td>
</tr>
<tr class="row-odd"><td>cftype</td>
<td>&#8216;weight&#8217;</td>
<td>The type of filtering that is applied to remove the continuum.  &#8216;weight&#8217;
refers to the weighted median, which uses the calculated zlevel sky as the
weight. &#8216;median&#8217; refers to a rolling median filter with a nested small
uniform filter. The &#8216;weight&#8217; option provides a better result, but is much
slower (an additional 10 minutes on a single exposure) and should only be
run in the complete sky subtraction case.</td>
</tr>
<tr class="row-even"><td>cfwidthSP</td>
<td>100</td>
<td>Size of the filterbox used to remove the continuum features for creating the
eigenbasis.</td>
</tr>
<tr class="row-odd"><td>cfwidthEV</td>
<td>50</td>
<td>Size of the filterbox used to remove the continuum features for calculating
the eigenvalues per spectrum</td>
</tr>
<tr class="row-even"><td>optimize</td>
<td>&#8216;normal&#8217;</td>
<td>A flag used to call the optimization method. The possible options are
&#8216;normal&#8217;, &#8216;enhanced&#8217;, and &#8216;none&#8217;.</td>
</tr>
<tr class="row-odd"><td>nevals</td>
<td>[]</td>
<td>This option is used for the manual selection of the the number of eigenvectors
to be used. If this is used, the pevals is ignored. Provide either a single
value that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</td>
</tr>
<tr class="row-even"><td>pevals</td>
<td>[]</td>
<td>This option is used for the manual selection of the the number of eigenvectors
to be used. This value is the percentage of the calculated
eigenspectra/eigenvalues used per spectral segment. Provide either a single
value that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</td>
</tr>
<tr class="row-odd"><td>extSVD</td>
<td>&#8216;&#8217;</td>
<td>An optional parameter that allows the input of a externally calculated
eigenbasis as well as a zlevel. This can be constructed from either a masked
version of a sparse field case, or an external sky frame.</td>
</tr>
<tr class="row-even"><td>mask</td>
<td>&#8216;&#8217;</td>
<td>A 2D fits image to exclude regions that may contaminate the zlevel or
eigenspectra. This image should be constructed from the datacube itself to
match the dimensionality. Sky regions should be marked as 0, and astronomical
sources should be identified with an integer greater than or equal to 1.</td>
</tr>
<tr class="row-odd"><td>interactive</td>
<td>False</td>
<td>Setting this option to True will allow the user to pass out the zclass which
contains all of the data and methods of ZAP. We describe this use below.</td>
</tr>
</tbody>
</table>
<p>The code can handle datacubes trimmed in wavelength space. Since the code uses the correlation of segments of the emission line spectrum, it is best to trim the cube at specific wavelengths. The cube can include any connected subset of these segments. (for example 6400 - 8200 Angstroms)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">4500</span><span class="p">,</span> <span class="mi">5400</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5400</span><span class="p">,</span> <span class="mi">5850</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5850</span><span class="p">,</span> <span class="mi">6440</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6440</span><span class="p">,</span> <span class="mi">6750</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6750</span><span class="p">,</span> <span class="mi">7200</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7200</span><span class="p">,</span> <span class="mi">7700</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7700</span><span class="p">,</span> <span class="mi">8265</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8265</span><span class="p">,</span> <span class="mi">8602</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8602</span><span class="p">,</span> <span class="mi">8731</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8731</span><span class="p">,</span> <span class="mi">9275</span><span class="p">]</span>
<span class="p">[</span><span class="mi">9275</span><span class="p">,</span> <span class="mi">9500</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="sparse-field-case">
<h2>Sparse Field Case<a class="headerlink" href="#sparse-field-case" title="Permalink to this headline">¶</a></h2>
<p>As noted above, this case can be handled simply with the observed datacube itself, using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases, the code will create a resulting processed datacube named &#8216;DATACUBE_ZAP.fits&#8217; and an SVD file named &#8216;ZAP_SVD.fits&#8217; in the current directory.</p>
</div>
<div class="section" id="masked-processing">
<h2>Masked Processing<a class="headerlink" href="#masked-processing" title="Permalink to this headline">¶</a></h2>
<p>Another option is to use a mask to isolate a sky within an exposure to pre-determine the zlevel and eigenspectra, which is then passed back into zap. This approach will allow the inclusion of a mask file, which is a 2d fits image matching the spatial dimensions of the input datacube. The values in the mask image will be 0 in the masked regions (such a where an extended object is) and 1 in the unmasked regions. Set this parameter with <tt class="docutils literal"><span class="pre">mask='maskfile.fits'</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s">&#39;mask.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filled-field-case">
<h2>Filled Field Case<a class="headerlink" href="#filled-field-case" title="Permalink to this headline">¶</a></h2>
<p>This approach also can address the saturated field case and is robust in the case of strong emission lines, in this case the input is an offset sky observation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">SVDoutput</span><span class="p">(</span><span class="s">&#39;Offset_Field_CUBE.fits&#39;</span><span class="p">,</span> <span class="n">svdfn</span><span class="o">=</span><span class="s">&#39;Offset_ZAP_SVD.fits&#39;</span><span class="p">)</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">extSVD</span><span class="o">=</span><span class="s">&#39;ZAP_SVD.fits&#39;</span><span class="p">,</span> <span class="n">cfwidth</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>The integration time of this frame does not need to be the same as the object exposure, but rather just a 2-3 minute exposure.</p>
<div class="section" id="top-level-functions">
<h3>Top Level Functions<a class="headerlink" href="#top-level-functions" title="Permalink to this headline">¶</a></h3>
<p>Aside from the main &#8220;full process&#8221;, two functions are included that can be run outside of the entire zap process to facilitate some investigations.</p>
<p><strong>nan cleaning</strong></p>
<p>This function replaces the nan valued pixels with an average of the adjacent valid pixels. It can be called as below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">nancleanfits</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">outfn</span><span class="o">=</span><span class="s">&#39;NANCLEAN_CUBE.fits&#39;</span><span class="p">,</span> <span class="n">rejectratio</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">boxsz</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8220;rejectratio&#8221; defines a cutoff for the ratio of pixels in a spaxel before the spaxel is avoided completely.</p>
<p>&#8220;boxsz&#8221; defines the number of pixels that defines the box around the offending nan pixel. With boxsz set to 1 the function looks for the nearest 26 neighbors which is a 3x3x3 cube.</p>
<p>This step is an intermediary step in the full ZAP process, but this function allows you to run it as a standalone step.</p>
<p><strong>continuum removal</strong></p>
<p>This function applies a filter on the datacube that removes most continuum features. This function allows for the enhancement of emission line characteristics. The filtering method has been enhanced by multiprocessing to produce a rapid result. It can be called as below:</p>
<div class="highlight-python"><div class="highlight"><pre>zap.contsubfits(musecubefits, contsubfn=&#39;CONTSUB_CUBE.fits&#39;, cfilter=100):
</pre></div>
</div>
<p>It applies a nested set of filters, one uniform of width 3 pixels and one median with a width defined by cfilter. Since it does not calculate a zlevel, it can only use the &#8216;median&#8217; method.</p>
</div>
<div class="section" id="interactive-mode">
<h3>Interactive mode<a class="headerlink" href="#interactive-mode" title="Permalink to this headline">¶</a></h3>
<p>ZAP can also  be used interactively from within ipython using pyfits.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">mpdaf_user</span> <span class="kn">import</span> <span class="n">zap</span>
<span class="n">zclass</span> <span class="o">=</span> <span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The run method operates on the datacube, and retains all of the data and methods necessary to
process a final data cube in a python class named zclass. You can elect to investigate the data product via the zclass, and even reprocess the cube with a different number of eigenspectra per region.  A workflow may go as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>from mpdaf_user import zap
from matplotlib import pyplot as plt

zobj = zap.process(&#39;INPUT.fits&#39;, optimization=&#39;normal&#39;) #allow ZAP to run the optimize routine
zobj.plotvarcurve(5) #plot the variance curves and the selection of the number of eigenspectra used

#plot a spectrum extracted from the original cube
plt.figure()
plt.plot(zobj.cube[:,50:100,50:100].sum(axis=(1,2)), &#39;b&#39;, alpha=0.3)

#plot a spectrum of the cleaned ZAP dataproduct
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2)), &#39;g&#39;)

#choose just the first 3 spectra for all segmments
zobj.reprocess(nevals=3)

#plot a spectrum extracted from the original cube
plt.plot(zobj.cube[:,50:100,50:100].sum(axis=(1,2)), &#39;b&#39;, alpha=0.3)

#plot a spectrum of the cleaned ZAP dataproduct
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;g&#39;)

#choose some number of modes by hand
zobj.reprocess(nevals=[2,5,2,4,6,7,9,8,5])

#plot a spectrum
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;k&#39;)

#Use the optimization algorithm to identify the best number of modes per segment
zobj.optimize()

#compare to the previous versions
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;r&#39;)

#identify a pixel in the dispersion axis that shows a residual feature in the original
plt.figure()
plt.matshow(zobj.cube[2903,:,:])

#compare this to the zap dataproduct
plt.figure()
plt.matshow(zobj.cleancube[2903,:,:])

#write the processed cube as a single extension fits
zobj.writecube(&#39;DATACUBE_ZAP.fits&#39;)

#or merge the zap datacube into the original input datacube, replacing the data extension
zobj.writefits(outcubefits=&#39;DATACUBE_FINAL_ZAP.fits&#39;)
</pre></div>
</div>
</div>
<div class="section" id="zclass">
<h3>ZCLASS<a class="headerlink" href="#zclass" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="zap.zclass">
<em class="property">class </em><tt class="descclassname">zap.</tt><tt class="descname">zclass</tt><big>(</big><em>musecubefits</em><big>)</big><a class="headerlink" href="#zap.zclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Main class to run each of the steps of ZAP.</p>
<dl class="docutils">
<dt>cleancube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The final datacube after removing all of the residual features.</dd>
<dt>contarray <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 2D array containing the subtracted continuum per spaxel.</dd>
<dt>cube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The original cube with the zlevel subtraction performed per spaxel.</dd>
<dt>especeval <span class="classifier-delimiter">:</span> <span class="classifier">list of (eigenspectra, eval)</span></dt>
<dd>A list containing the full set of eigenspectra and eigenvalues
generated by the SVD calculation that is used toy reconstruct the
entire datacube.</dd>
<dt>laxis <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the wavelength solution generated from the header
parameters.</dd>
<dt>lparams <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>An array of parameters taken from the header to generate the wavelength
solution.</dd>
<dt>lranges <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>A list of the wavelength bin limits used in segmenting the sepctrum
for SVD.</dd>
<dt>lmin,lmax <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The wavelength limits placed on the datacube.</dd>
<dt>nancube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 3d boolean datacube containing True in voxels where a NaN value was
replaced with an interpolation.</dd>
<dt>nevals <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the number of eigenvalues used per segment to
reconstruct the residuals.</dd>
<dt>normstack <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A normalized version of the datacube decunstructed into a 2d array.</dd>
<dt>varlist <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>An array for each segment with the variance curve, calculated for the
optimize method.</dd>
<dt>pranges <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The pixel indices of the bounding regions for each spectral segment.</dd>
<dt>recon <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 2d array containing the reconstructed emission line residuals.</dd>
<dt>run_clean <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Boolean that indicates that the NaN cleaning method was used.</dd>
<dt>run_zlevel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Boolean indicating that the zero level correction was used.</dd>
<dt>stack <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The datacube deconstructed into a 2d array for use in the the SVD.</dd>
<dt>subespeceval <span class="classifier-delimiter">:</span> <span class="classifier">list of (eigenspectra, eval)</span></dt>
<dd>The subset of eigenvalues and eigenspectra used to reconstruct the sky
residuals.</dd>
<dt>variancearray <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A list of length nsegments containing variances calculated per spaxel
used for normalization</dd>
<dt>y,x <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The position in the cube of the spaxels that are in the 2d
deconstructed stack</dd>
<dt>zlsky <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the result of the zero level subtraction</dd>
</dl>
<dl class="method">
<dt id="zap.zclass.chooseevals">
<tt class="descname">chooseevals</tt><big>(</big><em>nevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>pevals=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#zap.zclass.chooseevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the number of eigenspectra/evals to use for reconstruction.</p>
<p>User supplies the number of eigen spectra to be used (neval) or the
percentage of the eigenspectra that were calculated (peval) from each
spectral segment to be used.</p>
<p>The user can either provide a single value to be used for all segments,
or provide an array that defines neval or peval per segment.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.make_contcube">
<tt class="descname">make_contcube</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.make_contcube" title="Permalink to this definition">¶</a></dt>
<dd><p>Remold the continuum array so it can be investigated.</p>
<p>Takes the continuum stack and returns it into a familiar cube form.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.mergefits">
<tt class="descname">mergefits</tt><big>(</big><em>outcubefits</em><big>)</big><a class="headerlink" href="#zap.zclass.mergefits" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the ZAP cube into the full muse datacube and write.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.optimize">
<tt class="descname">optimize</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to optimize the number of components used to characterize
the residuals.</p>
<p>This function calculates the variance per segment with an increasing
number of eigenspectra/eigenvalues. It then deterimines the point at
which the second derivative of this variance curve reaches zero. When
this occurs, the linear reduction in variance is attributable to the
removal of astronomical features rather than emission line residuals.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reconstruct">
<tt class="descname">reconstruct</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.reconstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct the residuals from a given set of eigenspectra and
eigenvalues</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.remold">
<tt class="descname">remold</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.remold" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts the reconstructed residuals and places the cleaned
spectra into the duplicated datacube.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reprocess">
<tt class="descname">reprocess</tt><big>(</big><em>pevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>nevals=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#zap.zclass.reprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>A method that redoes the eigenvalue selection, reconstruction, and
remolding of the data.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeSVD">
<tt class="descname">writeSVD</tt><big>(</big><em>svdoutputfits='ZAP_SVD.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the SVD to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writecube">
<tt class="descname">writecube</tt><big>(</big><em>outcubefits='DATACUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writecube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeskycube">
<tt class="descname">writeskycube</tt><big>(</big><em>skycubefits='SKYCUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeskycube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to ZAP&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#sparse-field-case">Sparse Field Case</a></li>
<li><a class="reference internal" href="#masked-processing">Masked Processing</a></li>
<li><a class="reference internal" href="#filled-field-case">Filled Field Case</a><ul>
<li><a class="reference internal" href="#top-level-functions">Top Level Functions</a></li>
<li><a class="reference internal" href="#interactive-mode">Interactive mode</a></li>
<li><a class="reference internal" href="#zclass">ZCLASS</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">zap 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Kurt Soto, Simon Lilly.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>