<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to ZAP’s documentation! &mdash; zap 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="zap 1.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">zap 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-zap-s-documentation">
<h1>Welcome to ZAP&#8217;s documentation!<a class="headerlink" href="#welcome-to-zap-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p>ZAP (the Zurich Atmosphere Purge) is a high precision sky subtraction tool which can be used as complete sky subtraction solution, or as an enhancement to previously sky-subtracted data.  The method uses PCA to isolate the residual sky subtraction features and remove them from the observed datacube. Though the operation of ZAP is not dependent on perfect flatfielding of the data in a MUSE exposure, better results are obtained when these corrections are made ahead of time.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>ZAP requires the following packages:</p>
<ul class="simple">
<li>Numpy 1.6.0 or later</li>
<li>Astropy v1.0 or later</li>
<li>SciPy v0.13.3 or later</li>
</ul>
<p>Many linear algebra operations are performed in ZAP, so it can be beneficial to use an alternative BLAS package. In the Anaconda distribution, the default BLAS comes with numpy linked to OpenBlas, which can amount to a 20% speedup of ZAP.</p>
</div>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>The main function is <tt class="docutils literal"><span class="pre">zap.process</span></tt></p>
<dl class="function">
<dt id="zap.process">
<tt class="descclassname">zap.</tt><tt class="descname">process</tt><big>(</big><em>musecubefits</em>, <em>outcubefits='DATACUBE_FINAL_ZAP.fits'</em>, <em>clean=True</em>, <em>zlevel='median'</em>, <em>cftype='weight'</em>, <em>cfwidthEV=100</em>, <em>cfwidthSP=50</em>, <em>pevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>nevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>optimizeType='normal'</em>, <em>extSVD=None</em>, <em>skycubefits=None</em>, <em>svdoutputfits='ZAP_SVD.fits'</em>, <em>mask=None</em>, <em>interactive=False</em><big>)</big><a class="headerlink" href="#zap.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the entire ZAP sky subtraction algorithm.</p>
<p>Work on an input FITS file and optionally writes the product to an output
FITS file.</p>
<dl class="docutils">
<dt>musecubefits <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Input FITS file, containing a cube with data in the first extension.</dd>
<dt>outcubefits <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Output FITS file, based on the input one to propagate all header
information and other extensions. Default to DATACUBE_FINAL_ZAP.fits</dd>
<dt>clean <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True (default value), the NaN values are cleaned. Spaxels with more
then 25% of NaN values are removed, the others are replaced with an
interpolation from the neighbors.</dd>
<dt>zlevel <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Method for the zeroth order sky removal: <cite>none</cite>, <cite>sigclip</cite> or <cite>median</cite>
(default).</dd>
<dt>cftype <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Method for the continuum filter: <cite>median</cite> or <cite>weight</cite> (default). For
the <cite>weight</cite> method, a zeroth order sky is required (see <cite>zlevel</cite>).</dd>
<dt>cfwidthEV <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Window size for the continuum filter, for the SVD computation.
Default to 100.</dd>
<dt>cfwidthSP <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Window size for the continuum filter. Default to 50.</dd>
<dt>optimizeType <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Optimization method to compute the number of eigenspectra used for each
segment: <cite>none</cite>, <cite>normal</cite> (default), <cite>enhanced</cite>. If <cite>none</cite>, the number
of eigenspectra must be specified with <cite>nevals</cite> or <cite>pevals</cite>, otherwise
<cite>normal</cite> is used.</dd>
<dt>pevals <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>Allow to specify the percentage of eigenspectra used for each segment.</dd>
<dt>nevals <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>Allow to specify the number of eigenspectra used for each segment.</dd>
<dt>extSVD <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Path of an input FITS file containing a SVD computed by the
<tt class="docutils literal"><span class="pre">SVDoutput</span></tt> function. Otherwise the SVD is computed.</dd>
<dt>skycubefits <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Path for the optional output of the sky that is subtracted from the
cube. This is simply the input cube minus the output cube.</dd>
<dt>svdoutputfits <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Output FITS file. Default to ZAP_SVD.fits</dd>
<dt>interactive <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, an object containing all information on the ZAP process is
returned, and can be used to explore the eigenspectra and recompute the
output (with the <tt class="docutils literal"><span class="pre">reprocess</span></tt> method). In this case, the output files
are not saved (<cite>outcubefits</cite> and <cite>skycubefits</cite> are ignored). Default to
False.</dd>
</dl>
</dd></dl>

<p>In its most hands-off form, ZAP can take an input fits datacube, operate on it, and output a final fits datacube.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">zap</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Care should be taken, however, since this case assumes a sparse field, and better results can be obtained by applying masks.</p>
<p>There are a number of options that can be passed to the code which we tabulate here, and describe in several different use cases.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="18%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword</th>
<th class="head">Default</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>outcubefits</td>
<td>&#8216;DATACUBE_ZAP.fits&#8217;</td>
<td>the fits filename for the output datacube.</td>
</tr>
<tr class="row-odd"><td>clean</td>
<td>True</td>
<td>Interpolates over NaN values in the datacube to allow processing on all
spectra. The NaN values are replaced in the final datacube.
Any spaxel that includes a NaN pixel will hinder the calculation, so this
step is used to maximize the number of contributors. The NaN values are
reinserted into the final datacube.</td>
</tr>
<tr class="row-even"><td>zlevel</td>
<td>&#8216;median&#8217;</td>
<td>This option is used to define the method for determining the zeroth order
subtraction of the sky. This is used to remove any systematic sky feature
that exists over the whole field. Options are &#8216;median&#8217;, &#8216;sigclip&#8217;, and &#8216;none&#8217;.
The &#8216;none&#8217; option should only be applied when ZAP is applied to enhance a
previous sky subtraction.</td>
</tr>
<tr class="row-odd"><td>cftype</td>
<td>&#8216;weight&#8217;</td>
<td>The type of filtering that is applied to remove the continuum.  &#8216;weight&#8217;
refers to the weighted median, which uses the calculated zlevel sky as the
weight. &#8216;median&#8217; refers to a rolling median filter with a nested small
uniform filter. The &#8216;weight&#8217; option provides a better result, but is much
slower (an additional 10 minutes on a single exposure) and should only be
run in the complete sky subtraction case.</td>
</tr>
<tr class="row-even"><td>cfwidthSP</td>
<td>100</td>
<td>Size of the filterbox used to remove the continuum features for creating the
eigenbasis.</td>
</tr>
<tr class="row-odd"><td>cfwidthEV</td>
<td>50</td>
<td>Size of the filterbox used to remove the continuum features for calculating
the eigenvalues per spectrum</td>
</tr>
<tr class="row-even"><td>optimize</td>
<td>&#8216;normal&#8217;</td>
<td>A flag used to call the optimization method. The possible options are
&#8216;normal&#8217;, &#8216;enhanced&#8217;, and &#8216;none&#8217;.</td>
</tr>
<tr class="row-odd"><td>nevals</td>
<td>[]</td>
<td>This option is used for the manual selection of the the number of eigenvectors
to be used. If this is used, the pevals is ignored. Provide either a single
value that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</td>
</tr>
<tr class="row-even"><td>pevals</td>
<td>[]</td>
<td>This option is used for the manual selection of the the number of eigenvectors
to be used. This value is the percentage of the calculated
eigenspectra/eigenvalues used per spectral segment. Provide either a single
value that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</td>
</tr>
<tr class="row-odd"><td>extSVD</td>
<td>&#8216;&#8217;</td>
<td>An optional parameter that allows the input of a externally calculated
eigenbasis as well as a zlevel. This can be constructed from either a masked
version of a sparse field case, or an external sky frame.</td>
</tr>
<tr class="row-even"><td>mask</td>
<td>&#8216;&#8217;</td>
<td>A 2D fits image to exclude regions that may contaminate the zlevel or
eigenspectra. This image should be constructed from the datacube itself to
match the dimensionality. Sky regions should be marked as 0, and astronomical
sources should be identified with an integer greater than or equal to 1.</td>
</tr>
<tr class="row-odd"><td>interactive</td>
<td>False</td>
<td>Setting this option to True will allow the user to pass out the zclass which
contains all of the data and methods of ZAP. We describe this use below.</td>
</tr>
</tbody>
</table>
<p>The code can handle datacubes trimmed in wavelength space. Since the code uses the correlation of segments of the emission line spectrum, it is best to trim the cube at specific wavelengths. The cube can include any connected subset of these segments. (for example 6400 - 8200 Angstroms)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">5400</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5400</span><span class="p">,</span> <span class="mi">5850</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5850</span><span class="p">,</span> <span class="mi">6440</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6440</span><span class="p">,</span> <span class="mi">6750</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6750</span><span class="p">,</span> <span class="mi">7200</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7200</span><span class="p">,</span> <span class="mi">7700</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7700</span><span class="p">,</span> <span class="mi">8265</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8265</span><span class="p">,</span> <span class="mi">8602</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8602</span><span class="p">,</span> <span class="mi">8731</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8731</span><span class="p">,</span> <span class="mi">9275</span><span class="p">]</span>
<span class="p">[</span><span class="mi">9275</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="sparse-field-case">
<h2>Sparse Field Case<a class="headerlink" href="#sparse-field-case" title="Permalink to this headline">¶</a></h2>
<p>As noted above, this case can be handled simply with the observed datacube itself, using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases, the code will create a resulting processed datacube named &#8216;DATACUBE_ZAP.fits&#8217; and an SVD file named &#8216;ZAP_SVD.fits&#8217; in the current directory.</p>
</div>
<div class="section" id="masked-processing">
<h2>Masked Processing<a class="headerlink" href="#masked-processing" title="Permalink to this headline">¶</a></h2>
<p>Another option is to use a mask to isolate a sky within an exposure to pre-determine the zlevel and eigenspectra, which is then passed back into zap. This approach will allow the inclusion of a mask file, which is a 2d fits image matching the spatial dimensions of the input datacube. Masks are defined to be &gt;= 1 on astronomical sources and 0 at the position of the sky. Set this parameter with the <tt class="docutils literal"><span class="pre">mask</span></tt> keyword</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s">&#39;mask.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filled-field-case">
<h2>Filled Field Case<a class="headerlink" href="#filled-field-case" title="Permalink to this headline">¶</a></h2>
<p>This approach also can address the saturated field case and is robust in the case of strong emission lines, in this case the input is an offset sky observation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">SVDoutput</span><span class="p">(</span><span class="s">&#39;Offset_Field_CUBE.fits&#39;</span><span class="p">,</span> <span class="n">svdfn</span><span class="o">=</span><span class="s">&#39;ZAP_SVD.fits&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s">&#39;mask.fits&#39;</span><span class="p">)</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;Source_cube.fits&#39;</span><span class="p">,</span> <span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">extSVD</span><span class="o">=</span><span class="s">&#39;ZAP_SVD.fits&#39;</span><span class="p">,</span> <span class="n">cfwidth</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>The integration time of this frame does not need to be the same as the object exposure, but rather just a 2-3 minute exposure.</p>
<div class="section" id="extra-functions">
<h3>Extra Functions<a class="headerlink" href="#extra-functions" title="Permalink to this headline">¶</a></h3>
<p>Aside from the main process, two functions are included that can be run outside of the entire zap process to facilitate some investigations.</p>
<dl class="function">
<dt id="zap.nancleanfits">
<tt class="descclassname">zap.</tt><tt class="descname">nancleanfits</tt><big>(</big><em>musecubefits</em>, <em>outfn='NANCLEAN_CUBE.fits'</em>, <em>rejectratio=0.25</em>, <em>boxsz=1</em><big>)</big><a class="headerlink" href="#zap.nancleanfits" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects NaN values in cube and removes them by replacing them with an
interpolation of the nearest neighbors in the data cube. The positions in
the cube are retained in nancube for later remasking.</p>
<dl class="docutils">
<dt>musecubefits <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Input FITS file, containing a cube with data in the first extension.</dd>
<dt>outfn <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Output FITS file. Default to NANCLEAN_CUBE.fits</dd>
<dt>rejectratio <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><dl class="first last docutils">
<dt>Defines a cutoff for the ratio of NAN to total pixels in a spaxel</dt>
<dd>before the spaxel is avoided completely. Default to 0.25</dd>
</dl>
</dd>
<dt>boxsz <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Defines the number of pixels around the offending NaN pixel.
Default to 1, which looks for the 26 nearest neighbors which
is a 3x3x3 cube.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="zap.wmedian">
<tt class="descclassname">zap.</tt><tt class="descname">wmedian</tt><big>(</big><em>spec</em>, <em>wt</em>, <em>cfwidth=100</em><big>)</big><a class="headerlink" href="#zap.wmedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a weighted median filtering of a 1d spectrum</p>
<p>Operates using a cumulative sum curve</p>
<dl class="docutils">
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>Input 1d spectrum to be filtered</dd>
<dt>wt <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A spectrum of equal length as the input array to provide the weights.</dd>
<dt>cfwidth <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Window size for the continuum filter, for the SVD computation.
Default to 100.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="interactive-mode">
<h3>Interactive mode<a class="headerlink" href="#interactive-mode" title="Permalink to this headline">¶</a></h3>
<p>ZAP can also  be used interactively from within ipython.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">zap</span>
<span class="n">zobj</span> <span class="o">=</span> <span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The run method operates on the datacube, and retains all of the data and methods necessary to process a final data cube in a python class named zclass. You can elect to investigate the data product via the zclass, and even reprocess the cube with a different number of eigenspectra per region.  A workflow may go as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>import zap
from matplotlib import pyplot as plt

zobj = zap.process(&#39;INPUT.fits&#39;, optimization=&#39;normal&#39;, interactive=True) #allow ZAP to run the optimize routine
zobj.plotvarcurve(5) #plot the variance curves and the selection of the number of eigenspectra used

#plot a spectrum extracted from the original cube
plt.figure()
plt.plot(zobj.cube[:,50:100,50:100].sum(axis=(1,2)), &#39;b&#39;, alpha=0.3)

#plot a spectrum of the cleaned ZAP dataproduct
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2)), &#39;g&#39;)

#choose just the first 3 spectra for all segmments
zobj.reprocess(nevals=3)

#plot a spectrum extracted from the original cube
plt.plot(zobj.cube[:,50:100,50:100].sum(axis=(1,2)), &#39;b&#39;, alpha=0.3)

#plot a spectrum of the cleaned ZAP dataproduct
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;g&#39;)

#choose some number of modes by hand
zobj.reprocess(nevals=[2,5,2,4,6,7,9,8,5])

#plot a spectrum
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;k&#39;)

#Use the optimization algorithm to identify the best number of modes per segment
zobj.optimize()

#compare to the previous versions
plt.plot(zobj.cleancube[:,50:100,50:100].sum(axis=(1,2))), &#39;r&#39;)

#identify a pixel in the dispersion axis that shows a residual feature in the original
plt.figure()
plt.matshow(zobj.cube[2903,:,:])

#compare this to the zap dataproduct
plt.figure()
plt.matshow(zobj.cleancube[2903,:,:])

#write the processed cube as a single extension fits
zobj.writecube(&#39;DATACUBE_ZAP.fits&#39;)

#or merge the zap datacube into the original input datacube, replacing the data extension
zobj.writefits(outcubefits=&#39;DATACUBE_FINAL_ZAP.fits&#39;)
</pre></div>
</div>
</div>
<div class="section" id="zclass">
<h3>ZCLASS<a class="headerlink" href="#zclass" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="zap.zclass">
<em class="property">class </em><tt class="descclassname">zap.</tt><tt class="descname">zclass</tt><big>(</big><em>musecubefits</em><big>)</big><a class="headerlink" href="#zap.zclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Main class to run each of the steps of ZAP.</p>
<dl class="docutils">
<dt>cleancube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The final datacube after removing all of the residual features.</dd>
<dt>contarray <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 2D array containing the subtracted continuum per spaxel.</dd>
<dt>cube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The original cube with the zlevel subtraction performed per spaxel.</dd>
<dt>especeval <span class="classifier-delimiter">:</span> <span class="classifier">list of (eigenspectra, eval)</span></dt>
<dd>A list containing the full set of eigenspectra and eigenvalues
generated by the SVD calculation that is used toy reconstruct the
entire datacube.</dd>
<dt>laxis <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the wavelength solution generated from the header
parameters.</dd>
<dt>wcs <span class="classifier-delimiter">:</span> <span class="classifier">astropy.wcs.WCS</span></dt>
<dd>WCS object with the wavelength solution.</dd>
<dt>lranges <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>A list of the wavelength bin limits used in segmenting the sepctrum
for SVD.</dd>
<dt>nancube <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 3d boolean datacube containing True in voxels where a NaN value was
replaced with an interpolation.</dd>
<dt>nevals <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the number of eigenvalues used per segment to
reconstruct the residuals.</dd>
<dt>normstack <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A normalized version of the datacube decunstructed into a 2d array.</dd>
<dt>varlist <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>An array for each segment with the variance curve, calculated for the
optimize method.</dd>
<dt>pranges <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The pixel indices of the bounding regions for each spectral segment.</dd>
<dt>recon <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 2d array containing the reconstructed emission line residuals.</dd>
<dt>run_clean <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Boolean that indicates that the NaN cleaning method was used.</dd>
<dt>run_zlevel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Boolean indicating that the zero level correction was used.</dd>
<dt>stack <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The datacube deconstructed into a 2d array for use in the the SVD.</dd>
<dt>subespeceval <span class="classifier-delimiter">:</span> <span class="classifier">list of (eigenspectra, eval)</span></dt>
<dd>The subset of eigenvalues and eigenspectra used to reconstruct the sky
residuals.</dd>
<dt>variancearray <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A list of length nsegments containing variances calculated per spaxel
used for normalization</dd>
<dt>y,x <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The position in the cube of the spaxels that are in the 2d
deconstructed stack</dd>
<dt>zlsky <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>A 1d array containing the result of the zero level subtraction</dd>
</dl>
<dl class="method">
<dt id="zap.zclass.chooseevals">
<tt class="descname">chooseevals</tt><big>(</big><em>nevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>pevals=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#zap.zclass.chooseevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the number of eigenspectra/evals to use for reconstruction.</p>
<p>User supplies the number of eigen spectra to be used (neval) or the
percentage of the eigenspectra that were calculated (peval) from each
spectral segment to be used.</p>
<p>The user can either provide a single value to be used for all segments,
or provide an array that defines neval or peval per segment.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.make_contcube">
<tt class="descname">make_contcube</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.make_contcube" title="Permalink to this definition">¶</a></dt>
<dd><p>Remold the continuum array so it can be investigated.</p>
<p>Takes the continuum stack and returns it into a familiar cube form.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.mergefits">
<tt class="descname">mergefits</tt><big>(</big><em>outcubefits</em><big>)</big><a class="headerlink" href="#zap.zclass.mergefits" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the ZAP cube into the full muse datacube and write.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.optimize">
<tt class="descname">optimize</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to optimize the number of components used to characterize
the residuals.</p>
<p>This function calculates the variance per segment with an increasing
number of eigenspectra/eigenvalues. It then deterimines the point at
which the second derivative of this variance curve reaches zero. When
this occurs, the linear reduction in variance is attributable to the
removal of astronomical features rather than emission line residuals.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reconstruct">
<tt class="descname">reconstruct</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.reconstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct the residuals from a given set of eigenspectra and
eigenvalues</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.remold">
<tt class="descname">remold</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.remold" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts the reconstructed residuals and places the cleaned
spectra into the duplicated datacube.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reprocess">
<tt class="descname">reprocess</tt><big>(</big><em>pevals=</em>, <span class="optional">[</span><span class="optional">]</span><em>nevals=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#zap.zclass.reprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>A method that redoes the eigenvalue selection, reconstruction, and
remolding of the data.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeSVD">
<tt class="descname">writeSVD</tt><big>(</big><em>svdoutputfits='ZAP_SVD.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the SVD to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writecube">
<tt class="descname">writecube</tt><big>(</big><em>outcubefits='DATACUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writecube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeskycube">
<tt class="descname">writeskycube</tt><big>(</big><em>skycubefits='SKYCUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeskycube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to ZAP&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#sparse-field-case">Sparse Field Case</a></li>
<li><a class="reference internal" href="#masked-processing">Masked Processing</a></li>
<li><a class="reference internal" href="#filled-field-case">Filled Field Case</a><ul>
<li><a class="reference internal" href="#extra-functions">Extra Functions</a></li>
<li><a class="reference internal" href="#interactive-mode">Interactive mode</a></li>
<li><a class="reference internal" href="#zclass">ZCLASS</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">zap 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Kurt Soto, Simon Lilly.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>